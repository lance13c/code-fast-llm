cfllm: true
file: file.dart
codeBlocks:
  - type: replace
    start: "import 'package:cloud_firestore/cloud_firestore.dart';"
    end: "import 'package:firebase_auth/firebase_auth.dart';"
    newCode: |
      import 'package:cloud_firestore/cloud_firestore.dart';
      import 'package:dancepass/events/event.dart';
      import 'package:firebase_auth/firebase_auth.dart';
      import 'package:geoflutterfire2/geoflutterfire2.dart';
  - type: replace
    start: "class EventService {"
    end: "final geo = GeoFlutterFire();"
    newCode: |
      class EventService {
        final FirebaseFirestore _firestore = FirebaseFirestore.instance;
        final FirebaseAuth _auth = FirebaseAuth.instance;
        final geo = GeoFlutterFire();
  - type: replace
    start: "Future<String> createDraftEvent() async {"
    end: "return eventRef.id;"
    newCode: |
      Future<String> createDraftEvent() async {
        final String? uid = _auth.currentUser?.uid;
        if (uid == null) {
          throw Exception('User is not authenticated.');
        }
        DocumentReference eventRef = _firestore.collection(usersCollection).doc(uid).collection(eventsCollection).doc();
        await eventRef.set({
          'id': eventRef.id,
          'creatorId': uid,
          'isPublished': false,
          'createdAt': FieldValue.serverTimestamp(),
        });
        return eventRef.id;
      }
  - type: replace
    start: "Future<void> saveEvent(Event event) async {"
    end: "await eventRef.set(eventData, SetOptions(merge: true));"
    newCode: |
      Future<void> saveEvent(Event event) async {
        if (event.id.isEmpty) {
          throw Exception('Event ID is empty, cannot save to Firestore.');
        }
        final String? uid = _auth.currentUser?.uid;
        if (uid == null) {
          throw Exception('User is not authenticated.');
        }
        DocumentReference eventRef = _firestore.collection(usersCollection).doc(uid).collection(eventsCollection).doc(event.id);
        Map<String, dynamic> eventData = event.toFirestore();
        await eventRef.set(eventData, SetOptions(merge: true));
      }
  - type: replace
    start: "Stream<Event> getEventStream(String eventId) {"
    end: "return Event.fromFirestore(snapshot.data()! as Map<String, dynamic>);"
    newCode: |
      Stream<Event> getEventStream(String eventId) {
        final String? uid = _auth.currentUser?.uid;
        if (uid == null) {
          throw Exception('User is not authenticated.');
        }
        DocumentReference eventRef = _firestore.collection(usersCollection).doc(uid).collection(eventsCollection).doc(eventId);
        return eventRef.snapshots().map((snapshot) {
          if (snapshot.exists && snapshot.data() != null) {
            return Event.fromFirestore(snapshot.data()! as Map<String, dynamic>);
          } else {
            return Event(id: eventId, geoPoint: GeoFirePoint(0, 0));
          }
        });
      }
  - type: replace
    start: "Stream<List<Event>> getEventsNearUser(GeoFirePoint center, double radius) {"
    end: "toList());"
    newCode: |
      Stream<List<Event>> getEventsNearUser(GeoFirePoint center, double radius) {
        final collectionRef = _firestore.collection(eventsCollection);
        return geo.collection(collectionRef: collectionRef)
          .within(center: center, radius: radius, field: 'location.geopoint')
          .map((docs) => docs.map((doc) => Event.fromFirestore(doc.data() as Map<String, dynamic>)).toList());
      }
